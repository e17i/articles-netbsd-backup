<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-12 Di. 17:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Backup and Restore on NetBSD</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Jörg Kollmann" />
<link rel="stylesheet" type="text/css" href="chrome/rethink.css" />
<img src="image1.jpg"/><div style="padding:2vh"><a style="font-weight:900; text-decoration:none" href="/">Home</a></div>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Backup and Restore on NetBSD</h1>

<div id="outline-container-org330914f" class="outline-2">
<h2 id="org330914f">Overview</h2>
<div class="outline-text-2" id="text-org330914f">
<p>
Putting together the bits and pieces of a backup and restore concept,
while not being rocket science, always seems to be a little bit
ungrateful. Most Admin Handbooks handle this topic only within few
pages. After replacing my old Mac Mini's OS by NetBSD, I tried to
implement an automated backup, allowing me to handle it similarly to
the time machine backups I've been using before.
Suggestions on how to improve are always welcome.
</p>
</div>
</div>

<div id="outline-container-org61acf80" class="outline-2">
<h2 id="org61acf80">Some thoughts about Strategy</h2>
<div class="outline-text-2" id="text-org61acf80">
<p>
The first thing you probably see when reading about these topics is
the advice, don't have a backup strategy but a recovery strategy. That
is, make sure your backups are actually in a usable shape and
be sure you know how to apply them in an emergency. Depending on how
much you value your data, you might want to store the backup media in
a physically remote place. At least, you should not store it on the
same disks to be backed up, but on detachable media or on a remote
computer. Also it should be set read-only after the backup is
finished, so it cannot accidently be damaged when accessing it.
</p>

<p>
The next question is how much time and space you want to dedicate to
your backups. When doing a full backup each
time, recovery is easy: just apply the latest backup. On the flip
side, each backup might take a long time and much storage space. So the
other extreme might be to only start with one full backup, afterwards always
backing up only the increments to the previous backup. Then, of course,
the restore is expensive as you need to apply each single backup from
first to last in right order to do a full restore. Tools like
<a href="https://netbsd.gw.com/cgi-bin/man-cgi?rsync">rsync(1)</a> mitigate by merging each increment into the
previous backup, managing a copy of the backed up file system. But
this collides with the requirement of not modifying previous backups.
</p>

<p>
As a compromise, the <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump">dump(8)</a> manpage suggests to do the next
increment only every second time&#x2014;that is, to generate the diff to
the same preceeding backup for the following two consecutive backups.
Besides that, it suggests generating weekly backups incrementing on
the original full backup. Finally, it suggests to build a new full
backup every four weeks, this way maintaining a three-level strategy
of stacked increments. Then,
in the worst case, like restoring the backup of a cycle's last day, you
need to apply the initial full backup, the last weekly increment and
the daily increments of the third, fifth and seventh day, so you need
to apply at most five backups to do a full restore.
</p>

<p>
<a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump">dump(8)</a> allows to define this using backup levels. Level 0 always is a
full backup. Each higher level generates the diff to the last lower
level's backup contents. So applying the dump levels <code>0 3 2 5 4 7 6</code>
for the first and <code>1 3 2 5 4 7 6</code> for the three next weeks
follows the backup plan skeched out above. Of course, you may always
fine-tune this to your needs.
</p>

<p>
Another plan would be to only backup personal data like your user
directories. Then the restore plan would include a fresh OS
setup, installing of all software needed and then fetching only the user
directories from backup. This doesn't guarantee you get to the same
state as before, as you probably haven't tagged the exact versions of
all software installed before.
</p>

<p>
As I want to be able to go back also after experimental software
updates, my plan has been to setup a full backup using <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump">dump(8)</a> and
<a href="https://netbsd.gw.com/cgi-bin/man-cgi?restore">restore(8)</a>, using the strategy suggested above. After setting up this plan and
seeing my incremental backups are much smaller than the full one (and
even the later weekly increments), I decided to modify the plan
sketched out above and also do the first monthly backup as level 1,
this way doing full backups only on demand (e.g. after a system
upgrade). After some time I will re-evaluate how this works in
practice.
</p>
</div>
</div>

<div id="outline-container-org5b3fd6a" class="outline-2">
<h2 id="org5b3fd6a">Accessing a remote backup device</h2>
<div class="outline-text-2" id="text-org5b3fd6a">
<p>
When you don't have a backup tape device, you probably instead should
have an external backup medium ready. In the easiest case, that device
may be attached directly to your computer, so you can just adress it's
device entry.
</p>

<p>
When it is attached to another computer, there are several options.
The first one would be to use the remote option of <code>dump</code>, which
indirectly acesses the remote computer using <a href="https://netbsd.gw.com/cgi-bin/man-cgi?ssh">ssh(1)</a> and  <a href="https://netbsd.gw.com/cgi-bin/man-cgi?rmt">rmt(8)</a>, so both must be installed
and accessable there. Then you can set environment variable
<code>RCMD_CMD</code> to <code>ssh</code> and address your device by option <code>-f
user@host:file</code>.
</p>

<p>
If <code>rmt</code> is not available, your next option would be to pipe to <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dd">dd(1)</a>
using <code>ssh</code>.
</p>
<div class="org-src-container">
<pre class="src src-shell">dump &lt;options&gt; | ssh -l &lt;user&gt; &lt;host&gt; dd <span style="color: #a0522d;">of</span>=/dev/&lt;dump-device&gt;
</pre>
</div>

<p>
The pipe for the way back to restore then would be like this:
</p>
<div class="org-src-container">
<pre class="src src-shell">ssh -l &lt;user&gt; &lt;host&gt; dd <span style="color: #a0522d;">if</span>=/dev/&lt;dump-device&gt; | restore -f -
</pre>
</div>
<p>
where <code>/dev/dump-device</code> might also be a path to a plain file. 
Unfortunately, doing an interactive restore via this sort of piped ssh
seems to be not such a good idea, especially if the backup file is
large. Nevertheless, as a last resort this might be an option.
</p>

<p>
In my case, the backup device is an Apple Time Capsule, being also a
NetBSD-operated device. My first plan, using the remote backup
facility of <code>dump</code>, didn't work out because of the missing <code>rmt</code>
command on the time capsule. Perhaps some day I'll try to find a
statically linked <code>rmt</code> binary for NetBSD-6.0/evbarm (or cross-build
it myself). For now, I'm resolving to using <code>mount_afp</code>, provided
by pkgsrc, and mounting the time capsule filesystem to access it in a
less sophisticated way.
</p>

<p>
BTW, when doing so, I had to manually create a link to <code>/dev/fuse0</code>
(<code>ln -s /dev/putter /dev/fuse0</code>) to make <code>afpfsd</code> work.
</p>
</div>
</div>

<div id="outline-container-org1d2fd9f" class="outline-2">
<h2 id="org1d2fd9f">Snapshots</h2>
<div class="outline-text-2" id="text-org1d2fd9f">
<p>
One downside of using <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump">dump(8)</a> is, it cannot reliably take backups from
live file systems. That used to imply the need to go down to single user and
umount the files systems for each backup. Fortunately, NetBSD has a
nice support for file system snapshots courtesy of <a href="https://netbsd.gw.com/cgi-bin/man-cgi?fssconfig">fssconfig(8)</a>,
easing the backup process very much.
</p>

<p>
As root, for example, use
</p>
<div class="org-src-container">
<pre class="src src-shell">fssconfig -cv fss0 / /root/snapshot
</pre>
</div>
<p>
to snapshot the file system and make the snapshot reachable through
the <code>/dev/fss0</code> device. The file <code>/root/snapshot</code> is used internally
to manage the snapshot while the filesystems stays live. You can then
mount the device read-only and see the unchanged directory, even if
you change the live filesystem.
</p>

<p>
<code>fssconfig -l</code> shows the snapshot devices currently in use. With
<code>fssconfig -u</code> you can remove a snapshot after dumping it. Afterwards,
the snapshot file can also be removed.
</p>

<p>
<code>dump</code> logs the time, device and level of each dump into
<code>/etc/dumpdates</code>. Normally, the file system devices are used here. 
But when using fss snapshots, as the fss device name is written into
dumpdates instead, you should always consistently use the same different fss
device numbers when dumping different file systems. For example use <code>fss0</code> for
root, <code>fss1</code> for <code>usr</code> when they are on different mount points, etc.
</p>
</div>
</div>

<div id="outline-container-org11cbb9f" class="outline-2">
<h2 id="org11cbb9f">Restoring</h2>
<div class="outline-text-2" id="text-org11cbb9f">
<p>
All this is done to be able to walk the opposite way and restore a
damaged system. So, when in case of emergency, use <a href="https://netbsd.gw.com/cgi-bin/man-cgi?restore">restore(8)</a> to apply
your backups. It can do full or
partial restores and also has an interactive mode.
</p>

<div class="org-src-container">
<pre class="src src-shell">restore -t -f dump_file
</pre>
</div>
<p>
This doesn't modify anything, but only outputs the contents of the
backup. This is not only the file and directory names, but also the
dump date, level and in case of an incremental backup, the previous
level.
</p>

<p>
When doing a full restore into a fresh file system, prepare it using
<code>newfs</code> before. Afterwards, <code>mount</code> and <code>cd</code> into the new file system,
as the restored files go into the current directory.
</p>
<div class="org-src-container">
<pre class="src src-shell">restore -rf dump_file
</pre>
</div>
<p>
This rebuilds the file system. When the dump is done onto a set of
tapes (or other media) or when afterwards incremental dumps should be
applied, <code>restore</code> needs to pass information between the different runs. So it
creates a <code>restoresymtable</code> file in the root directory storing infos about it's
progress. Consequently, this file should be left
until the complete restore is finished.
</p>

<div class="org-src-container">
<pre class="src src-shell">restore -if dump_file
</pre>
</div>
<p>
This allows you to interactively look into a dump and select single
files or directories to be restored. <code>?</code> shows the commands available here.
Often, when you just want to get back
some older versions of a file, this is the most useful tool.
</p>

<div class="org-src-container">
<pre class="src src-shell">restore -xf dump_file
</pre>
</div>
<p>
This extracts single files or directories instead of doing a full
restore, so it also creates no <code>restoresymtable</code>.
</p>

<p>
And finally,
</p>
<div class="org-src-container">
<pre class="src src-shell">restore -ruf dump_file
</pre>
</div>
<p>
does a full restore, but can be used on a populated file system. It
unlinks and therefore replaces files by the versions from the backup.
So it can be used to try and repair a file system.
By the way, when applying an incremental backup after a full restore,
the files to be replaced by the increment are also unlinked before, so
this also works as expected without any need to specify the <code>-u</code> argument.
</p>

<p>
When restoring a backup done with the strategy skeched out above,
start with the (latest) level 0 dump, then work through all newer
dumps leaving out each one where a newer dump with lower level exists.
The dates and other infos about each dump file can be extracted from
output of <code>restore -t</code>, or interactively by using the <code>what</code> command
in <code>restore -i</code>. For example, when dumps were generated with order <code>0
3 2 4</code>, you'll find that for level 3 dump a newer one with lower level
exists (number 2), so 3 is left out. The only one with lower level
than 2 is the older 0, so you choose 2. 4 has also only lower ones
with older dates, so 4 is also choosen, giving the restore order <code>0 2
4</code>.
</p>
</div>
</div>

<div id="outline-container-org81241da" class="outline-2">
<h2 id="org81241da">Some notes on using dump and restore</h2>
<div class="outline-text-2" id="text-org81241da">
<p>
You can exclude files or directories from the backup by setting the
<code>nodump</code> flag. <code>ls -o</code> shows the current flags. Set <code>nonodump</code> to
remove a flag.
</p>
<div class="org-src-container">
<pre class="src src-shell">chflags nodump file-or-dir
ls -o
chflags nonodump file-or-dir
</pre>
</div>

<p>
By default, the <code>nodump</code> flags are honored for incremental backups
starting with level 1, but you can change this with the <code>dump -h</code>
option. I'm setting this to 0 to always have the flags honored.
</p>
<div class="org-src-container">
<pre class="src src-shell">dump 0a -h 0 -f /tmp/backup.1 /home
</pre>
</div>

<p>
Otherwise, you can also specify a list of paths, when only a subset of
a file system should be backed up. When doing this, <code>dump</code> is always
doing a full level 0 backup of the given directories.
</p>

<p>
When a long dump is running, you can send a <code>SIGSTATUS</code> to the dump
process to make it report it's progress. For example, when the status
control character is mapped to <code>CTRL-T</code> via <a href="https://netbsd.gw.com/cgi-bin/man-cgi?stty">stty(1)</a>, a dump process running in the
foreground reports the progress when pressing that (restore also).
</p>

<p>
If you are manually doing backups, besides looking at <code>/etc/dumpdates</code>
you can use <code>dump -w</code> to show the file systems currently to be dumped.
Otherwise, you can always use <code>dump -W</code> to show the last dump times and
levels of all dumped file systems.
</p>

<p>
The dump frequency in days, used to determine which file systems need
to be dumped next, can be defined in <code>/etc/fstab</code>'s fifth entry.
But when using snapshots, the devices actually dumped are not listed
in fstab, so this mechanism isn't working. Automating the backup in a
crontab and defining own dump entries with adjacent frequencies can
mitigate this.
</p>
</div>
</div>

<div id="outline-container-orgb43dafd" class="outline-2">
<h2 id="orgb43dafd">An example session</h2>
<div class="outline-text-2" id="text-orgb43dafd">
<p>
Here is an example of mounting/unmounting an afp backup device,
handling a file system snapshot and doing a full dump.
</p>

<div class="org-src-container">
<pre class="src src-shell">mount_afp afp://:passwd@host/path /mnt/backup
fssconfig -cv fss0 / /snapshot
mount -r /dev/fss0 /mnt/dev
dump -0ua -h 0 -f /mnt/backup/dumpfile.0 /mnt/dev
umount /mnt/dev
fssconfig -u fss0
rm /snapshot 
afp_client unmount /mnt/backup
</pre>
</div>

<p>
To do a restore, you would use the same sequence, replacing the <code>dump</code>
command perhaps with an interactive restore:
</p>
<div class="org-src-container">
<pre class="src src-shell">restore -if /mnt/backup/var
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd918245" class="outline-2">
<h2 id="orgd918245">Putting the pieces together</h2>
<div class="outline-text-2" id="text-orgd918245">
<p>
Finally, here is my <code>bin/backup.sh</code>. When sourced, provides some commands
to support handling snapshots, mounting of the backup device,
making an incremental backup following a configured strategy and
accessing/restoring from the backup device. For example, after
modifying the conf file to your needs, a manual
initial level 0 dump can be done like this:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">.</span> /root/bin/backup.sh &amp;&amp; backup - 0
</pre>
</div>
<p>
An interactive restore session of the last level 5 dump is done by
this:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">.</span> /root/bin/backup.sh &amp;&amp; restoredump - -i 5
</pre>
</div>
<p>
The script includes an example on how
to automate daily backups by calling it via crontab, saving the output
to a log and mailing it to root.
Take caution as this is not yet so well tested&#x2014;just use it as a simple example.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">!/usr/pkg/bin/</span><span style="color: #a020f0;">bash</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">copy and adapt the config vars into ~/etc/backup.conf</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">put auth info like DUMPDEVPWD into ~/.backup.conf</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">and set it chmod 400 and chflags nodump</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">install as root crontab like this:</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;"># daily backups</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">0       1       *       *       *       /usr/pkg/bin/bash -c '. /root/bin/backup.sh &amp;&amp; backup' 2&gt;&amp;1 | tee /var/log/backup.out | sendmail -t</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">30      1       *       *       *       /usr/pkg/bin/bash -c '. /root/bin/backup.sh &amp;&amp; backup /root/etc/backup-var.conf' 2&gt;&amp;1 | tee /var/log/backup-var.out | sendmail -t</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">uncomment to test backup config</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">TEST=echo</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">define this when dump device must be mounted</span>
<span style="color: #a0522d;">DUMPDEV</span>=afp://:${<span style="color: #a0522d;">DUMPDEVPWD</span>}@timecapsule/ 
<span style="color: #a0522d;">DUMPMNT</span>=/mnt/bkup

<span style="color: #b22222;"># </span><span style="color: #b22222;">unset if you dont want a snapshot</span>
<span style="color: #a0522d;">FSS</span>=fss0
<span style="color: #a0522d;">SRCDEV</span>=/
<span style="color: #a0522d;">SNAPSHOT</span>=/root/snapshot

<span style="color: #b22222;"># </span><span style="color: #b22222;">mountpoint of fs to backup</span>
<span style="color: #a0522d;">SRCMNT</span>=/mnt/dev

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup device or file</span>
<span style="color: #a0522d;">BACKUP</span>=${<span style="color: #a0522d;">DUMPMNT</span>}/client/dump
<span style="color: #b22222;">#</span><span style="color: #b22222;">BACKUP=</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup levels for each day of month</span>
<span style="color: #a0522d;">LEVELS</span>=(- 0 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2)

<span style="color: #0000ff;">dumpcmd</span>() {
  ${<span style="color: #a0522d;">TEST</span>} dump $<span style="color: #a0522d;">*</span>
}

<span style="color: #0000ff;">restorecmd</span>() {
  ${<span style="color: #a0522d;">TEST</span>} restore $<span style="color: #a0522d;">*</span>
}

<span style="color: #483d8b;">export</span> <span style="color: #a0522d;">PATH</span>=$<span style="color: #a0522d;">PATH</span>:/usr/pkg/bin

<span style="color: #b22222;"># </span><span style="color: #b22222;">absolute paths to use in root crontab</span>
<span style="color: #483d8b;">test</span> -f /root/.backup.conf &amp;&amp; <span style="color: #483d8b;">.</span> /root/.backup.conf
<span style="color: #483d8b;">test</span> -f /root/etc/backup.conf &amp;&amp; <span style="color: #483d8b;">.</span> /root/etc/backup.conf

<span style="color: #0000ff;">backup_dev</span>() {
  <span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${DUMPMNT}-"</span> != <span style="color: #8b2252;">"-"</span> ]; <span style="color: #a020f0;">then</span>
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"$1"</span><span style="color: #a020f0;"> in</span>
    mount) ${<span style="color: #a0522d;">TEST</span>} mount_afp ${<span style="color: #a0522d;">DUMPDEV</span>} ${<span style="color: #a0522d;">DUMPMNT</span>}
           ;;
    unmount) ${<span style="color: #a0522d;">TEST</span>} afp_client unmount ${<span style="color: #a0522d;">DUMPMNT</span>}
             ;;
    <span style="color: #a020f0;">esac</span>
  <span style="color: #a020f0;">fi</span>
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">when the time capsule needs to spin up, mount seems to fail</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">so a second try is done</span>
<span style="color: #0000ff;">mount_backup</span>() {
  backup_dev mount
  <span style="color: #a020f0;">if</span> [ $<span style="color: #a0522d;">?</span> -eq 2 ]; <span style="color: #a020f0;">then</span>
    backup_dev mount
  <span style="color: #a020f0;">fi</span>
}

<span style="color: #0000ff;">snapshot</span>() {
  <span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${FSS}-"</span> != <span style="color: #8b2252;">"-"</span> ]; <span style="color: #a020f0;">then</span>
    <span style="color: #a020f0;">case</span> $<span style="color: #a0522d;">1</span><span style="color: #a020f0;"> in</span>
    new) ${<span style="color: #a0522d;">TEST</span>} fssconfig -c ${<span style="color: #a0522d;">FSS</span>} ${<span style="color: #a0522d;">SRCDEV</span>} ${<span style="color: #a0522d;">SNAPSHOT</span>}
         ${<span style="color: #a0522d;">TEST</span>} chflags nodump ${<span style="color: #a0522d;">SNAPSHOT</span>}
         ${<span style="color: #a0522d;">TEST</span>} mount -r /dev/${<span style="color: #a0522d;">FSS</span>} ${<span style="color: #a0522d;">SRCMNT</span>}
         ;;
    rm) ${<span style="color: #a0522d;">TEST</span>} umount ${<span style="color: #a0522d;">SRCMNT</span>}
        ${<span style="color: #a0522d;">TEST</span>} fssconfig -u ${<span style="color: #a0522d;">FSS</span>}
        ${<span style="color: #a0522d;">TEST</span>} rm -f ${<span style="color: #a0522d;">SNAPSHOT</span>}
        ;;
    <span style="color: #a020f0;">esac</span>
  <span style="color: #a020f0;">fi</span>
}

<span style="color: #0000ff;">find_level</span>() {
  <span style="color: #b22222;"># </span><span style="color: #b22222;">find level for today</span>
  <span style="color: #a0522d;">LEV</span>=${<span style="color: #a0522d;">LEVELS</span>[<span style="color: #ff00ff;">`date '+%e'`</span>]}
  <span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${1}-"</span> != <span style="color: #8b2252;">"-"</span> ]; <span style="color: #a020f0;">then</span>
    <span style="color: #a0522d;">LEV</span>=${<span style="color: #a0522d;">1</span>}
  <span style="color: #a020f0;">fi</span>
  <span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${BACKUP}-"</span> != <span style="color: #8b2252;">"-"</span> ]; <span style="color: #a020f0;">then</span>
    <span style="color: #a0522d;">BACKUPFILE</span>=${<span style="color: #a0522d;">BACKUP</span>}<span style="color: #483d8b;">.</span>${<span style="color: #a0522d;">LEV</span>}
    <span style="color: #a0522d;">BOUT</span>=
  <span style="color: #a020f0;">else</span>
    <span style="color: #a0522d;">BACKUPFILE</span>=
    <span style="color: #a0522d;">BOUT</span>=-
  <span style="color: #a020f0;">fi</span>
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">makedump lev</span>
<span style="color: #0000ff;">makedump</span>() {
  find_level ${<span style="color: #a0522d;">1</span>}

  <span style="color: #b22222;"># </span><span style="color: #b22222;">save prev lev 0 dump as prevmonth</span>
  <span style="color: #a020f0;">if</span> [ ${<span style="color: #a0522d;">LEV</span>} -eq 0 ];<span style="color: #a020f0;">then</span>
    <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevmonth &amp;&amp; rm ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevmonth
    <span style="color: #483d8b;">test</span> <span style="color: #8b2252;">"${BACKUPFILE}-"</span> != <span style="color: #8b2252;">"-"</span> &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>} &amp;&amp; mv ${<span style="color: #a0522d;">BACKUPFILE</span>} ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevmonth
  <span style="color: #a020f0;">fi</span>

  <span style="color: #b22222;"># </span><span style="color: #b22222;">save prev lev 1 dump as prevweek</span>
  <span style="color: #a020f0;">if</span> [ ${<span style="color: #a0522d;">LEV</span>} -eq 1 ];<span style="color: #a020f0;">then</span>
    <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevweek &amp;&amp; rm ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevweek
    <span style="color: #483d8b;">test</span> <span style="color: #8b2252;">"${BACKUPFILE}-"</span> != <span style="color: #8b2252;">"-"</span> &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>} &amp;&amp; mv ${<span style="color: #a0522d;">BACKUPFILE</span>} ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevweek
  <span style="color: #a020f0;">fi</span>

  <span style="color: #b22222;"># </span><span style="color: #b22222;">and dump</span>
  dumpcmd ${<span style="color: #a0522d;">LEV</span>}ua -h 0 -f ${<span style="color: #a0522d;">BACKUPFILE</span>}${<span style="color: #a0522d;">BOUT</span>} ${<span style="color: #a0522d;">SRCMNT</span>} 
}

<span style="color: #0000ff;">mailheader</span>() {
  <span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"To: root"</span>
  <span style="color: #483d8b;">printf</span> <span style="color: #8b2252;">"Subject: %s backup dump output for %s\n\n"</span> <span style="color: #ff00ff;">`hostname`</span> <span style="color: #8b2252;">"`date`"</span>
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup [conf [lev]]</span>
<span style="color: #0000ff;">backup</span>() {
  mailheader
  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for custom conf</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 0 &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">1</span>} &amp;&amp; <span style="color: #483d8b;">.</span> ${<span style="color: #a0522d;">1</span>}
  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for lev</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 1 &amp;&amp; <span style="color: #a0522d;">LEV</span>=${<span style="color: #a0522d;">2</span>} || <span style="color: #a0522d;">LEV</span>=
  find_level $<span style="color: #a0522d;">LEV</span>

  snapshot new
  <span style="color: #b22222;"># </span><span style="color: #b22222;">backup_dev mount</span>
  mount_backup
  makedump $<span style="color: #a0522d;">LEV</span>
  backup_dev unmount
  snapshot rm
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">restoredump [conf [args [lev]]]</span>
<span style="color: #0000ff;">restoredump</span>() {
  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for custom conf</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 0 &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">1</span>} &amp;&amp; <span style="color: #483d8b;">.</span> ${<span style="color: #a0522d;">1</span>}

  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for args</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 1 &amp;&amp; <span style="color: #a0522d;">ARGS</span>=${<span style="color: #a0522d;">2</span>}

  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for lev</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 2 &amp;&amp; <span style="color: #a0522d;">LEV</span>=${<span style="color: #a0522d;">3</span>} || <span style="color: #a0522d;">LEV</span>=
  find_level $<span style="color: #a0522d;">LEV</span>

  <span style="color: #b22222;"># </span><span style="color: #b22222;">backup_dev mount</span>
  mount_backup
  restorecmd ${<span style="color: #a0522d;">ARGS</span>} -f ${<span style="color: #a0522d;">BACKUPFILE</span>}${<span style="color: #a0522d;">BOUT</span>}
  backup_dev unmount
}
</pre>
</div>

<p>
..and an example of a backup.conf showing how to dump/restore using
ssh pipes:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">comment to really do backups</span>
<span style="color: #a0522d;">TEST</span>=echo

<span style="color: #b22222;"># </span><span style="color: #b22222;">define this when dump device must be mounted</span>
<span style="color: #a0522d;">DUMPDEV</span>=afp://:${<span style="color: #a0522d;">DUMPDEVPWD</span>}@timecapsule/
<span style="color: #a0522d;">DUMPMNT</span>=/mnt/bkup

<span style="color: #b22222;"># </span><span style="color: #b22222;">unset if you dont want a snapshot</span>
<span style="color: #a0522d;">FSS</span>=fss0
<span style="color: #a0522d;">SRCDEV</span>=/
<span style="color: #a0522d;">SNAPSHOT</span>=/root/snapshot

<span style="color: #b22222;"># </span><span style="color: #b22222;">mountpoint of fs to backup</span>
<span style="color: #a0522d;">SRCMNT</span>=/mnt/dev

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup device or file</span>
<span style="color: #a0522d;">BACKUP</span>=${<span style="color: #a0522d;">DUMPMNT</span>}/client/dump
<span style="color: #b22222;">#</span><span style="color: #b22222;">BACKUP=</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup levels for each day of month</span>
<span style="color: #a0522d;">LEVELS</span>=(- 0 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2)

<span style="color: #b22222;"># </span><span style="color: #b22222;">uncomment this to define custom commands</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">dumpcmd() {</span>
<span style="color: #b22222;">#  </span><span style="color: #b22222;">dump $* | ssh timecapsule dd of=/Volumes/dk2/ShareRoot/client/dump.${LEV}</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">}</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">restorecmd() {</span>
<span style="color: #b22222;">#  </span><span style="color: #b22222;">ssh timecapsule dd if=/Volumes/dk2/ShareRoot/client/dump.${LEV} | restore $*</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7b67273" class="outline-2">
<h2 id="org7b67273">At the end&#x2026;</h2>
<div class="outline-text-2" id="text-org7b67273">
<p>
After a few days of automatic backups, this setup seems to work quite
reliably. The files are rotated and replaced in the expected order,
looking at the contents with interactive restore and doing a test recovery, everything looks
good. Having set up this kind of backups gives a good feeling&#x2014;now
lets make sure continuously this actually is justified..
</p>

<p>
As a side note, while experimenting with <code>dump</code> and <code>restore</code>, I found
the last dump made on my NeXTStep System some decades ago. And,
believe it or not, the <code>restore</code> command on 2020's NetBSD is still
able to read that old dump format. So when I'll find some more time, I
hope to restore it into a virtualized NeXTStep reincarnation. That
would be a recovery strategy having been working out really well!
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jörg Kollmann
(Reddit: <a href="https://www.reddit.com/user/e17i">u/e17i</a>)</p> <p>Made on
emacs org-mode with <a href="https://jessekelly881-rethink.surge.sh/">Rethink</a></p>
</div>
</body>
</html>
