<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-06-08 Mo. 12:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Backup and Restore on NetBSD</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Jörg Kollmann" />
<link rel="stylesheet" type="text/css" href="/chrome/rethink.css" />
<img src="/chrome/image1.jpg"/><div style="padding:2vh"><a style="font-weight:900; text-decoration:none" href="/">Home</a></div>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Backup and Restore on NetBSD</h1>

<div id="outline-container-org6470dfc" class="outline-2">
<h2 id="org6470dfc">Overview</h2>
<div class="outline-text-2" id="text-org6470dfc">
<p>
Putting together the bits and pieces of a backup and restore concept,
while not being rocket science, always seems to be a little bit
ungrateful. Most Admin Handbooks handle this topic only within few
pages. After replacing my old Mac Mini's OS by NetBSD, I tried to
implement an automated backup, allowing me to handle it similarly to
the time machine backups I've been using before.
Suggestions on how to improve are always welcome.
</p>
</div>
</div>

<div id="outline-container-orgf7b8a3f" class="outline-2">
<h2 id="orgf7b8a3f">Some thoughts about Strategy</h2>
<div class="outline-text-2" id="text-orgf7b8a3f">
<p>
The first thing you probably see when reading about these topics is
the advice, don't have a backup strategy but a recovery strategy. That
is, make sure your backups are actually in a usable shape and
be sure you know how to apply them in an emergency. Depending on how
much you value your data, you might want to store the backup media in
a physically remote place. At least, you should not store it on the
same disks to be backed up, but on detachable media or on a remote
computer. Also it should be set read-only after the backup is
finished, so it cannot accidently be damaged when accessing it.
</p>

<p>
The next question is how much time and space you want to dedicate to
your backups. When doing a full backup each
time, recovery is easy: just apply the latest backup. On the flip
side, each backup might take a long time and much storage space. So the
other extreme might be to only start with one full backup, afterwards always
backing up only the increments to the previous backup. Then, of course,
the restore is expensive as you need to apply each single backup from
first to last in right order to do a full restore. Tools like
<a href="https://netbsd.gw.com/cgi-bin/man-cgi?rsync"><code>rsync(1)</code></a> mitigate by merging each increment into the
previous backup, managing a copy of the backed up file system. But
this collides with the requirement of not modifying previous backups.
</p>

<p>
As a compromise, the manpage of the <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a> tool suggests to do the next
increment only every <i>nth</i> time (for example every second time)&#x2014;that is, to generate the diff to
the same preceeding backup for the following two consecutive backups.
Besides that, it suggests generating weekly backups incrementing on
the original full backup. Finally, it suggests to build a new full
backup every four weeks, this way maintaining a three-level strategy
of stacked increments. Then,
in the worst case, like restoring the backup of a cycle's last day, you
need to apply the initial full backup, the last weekly increment and
the daily increments of the third, fifth and seventh day, so you need
to apply at most five backups to do a full restore.
</p>

<p>
<a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a> allows to define this using backup levels. Level 0 always is a
full backup. Each higher level generates the diff to the last lower
level's backup contents. So applying the dump levels <code>0 3 2 5 4 7 6</code>
for the first and <code>1 3 2 5 4 7 6</code> for the three next weeks
follows the backup plan sketched out above. Of course, you may always
fine-tune this to your needs.
</p>

<p>
Another plan would be to only backup personal data like your user
directories. Then the restore plan would include a fresh OS
setup, installing of all software needed and then fetching only the user
directories from backup. This doesn't guarantee you get to the same
state as before, as you probably haven't tagged the exact versions of
all software installed before.
</p>

<p>
While there are many third party solutions out there, my plan is to
use the on-board capabilities for backup. This way, the restore tools are
in reach without additional installation steps. For instance,
the mini root ram disk of NetBSD's installation kernel at least contains the
<a href="https://netbsd.gw.com/cgi-bin/man-cgi?restore"><code>restore(8)</code></a> tool, mentioned below, on board.
</p>

<p>
As I want to be able to go back also after experimental software
updates, my plan has been to setup a full backup using <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a> and
<a href="https://netbsd.gw.com/cgi-bin/man-cgi?restore"><code>restore(8)</code></a>, using the strategy suggested above. After setting up this plan and
seeing my incremental backups are much smaller than the full one (and
even the later weekly increments), I decided to modify the plan
sketched out above and also do the first monthly backup as level 1,
this way doing full backups only on demand (e.g. after a system
upgrade). On the other side, when there are large diffs every day, it
may be more practical to just do a weekly full backup and daily incremental
backups diffing to the previous day. For example, in times when
compiling larger parts of pkgsrc, this seems to make sense.
</p>
</div>
</div>

<div id="outline-container-org540a1c7" class="outline-2">
<h2 id="org540a1c7">Accessing a remote backup device</h2>
<div class="outline-text-2" id="text-org540a1c7">
<p>
When you don't have a backup tape device, you probably instead should
have an external backup medium ready. In the easiest case, that device
may be attached directly to your computer, so you can just adress it's
device entry.
</p>

<p>
When it is attached to another computer, there are several options.
The first one would be to use the remote option of <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a>, which
indirectly acesses the remote computer using <a href="https://netbsd.gw.com/cgi-bin/man-cgi?ssh"><code>ssh(1)</code></a> and <a href="https://netbsd.gw.com/cgi-bin/man-cgi?rmt"><code>rmt(8)</code></a>, so both must be installed
and accessable there. Then you can set environment variable
<code>RCMD_CMD</code> to <code>ssh</code> and address your device by option <code>-f user@host:file</code>.
</p>

<p>
If, for example, <a href="https://netbsd.gw.com/cgi-bin/man-cgi?rmt"><code>rmt(8)</code></a> is not available, your next option suggested
by many tutorials would be to pipe to <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dd"><code>dd(1)</code></a>
using <a href="https://netbsd.gw.com/cgi-bin/man-cgi?ssh"><code>ssh(1)</code></a>.
</p>
<div class="org-src-container">
<pre class="src src-shell">dump &lt;options&gt; | ssh -l &lt;user&gt; &lt;host&gt; dd <span style="color: #a0522d;">of</span>=/dev/&lt;dump-device&gt;
</pre>
</div>

<p>
The pipe for the way back to restore then would be like this:
</p>
<div class="org-src-container">
<pre class="src src-shell">ssh -l &lt;user&gt; &lt;host&gt; dd <span style="color: #a0522d;">if</span>=/dev/&lt;dump-device&gt; | restore -f -
</pre>
</div>
<p>
where <code>/dev/dump-device</code> might also be a path to a plain file. 
Unfortunately, doing an interactive restore via this sort of piped ssh
seems to be not such a good idea, especially if the backup file is
large. Nevertheless, this might be an option for
doing non-interactive restores.
</p>

<p>
But if you can  <a href="https://netbsd.gw.com/cgi-bin/man-cgi?ssh"><code>ssh(1)</code></a> into a remote box, the easiest way to get it
within reach would be to just  mount it using  <a href="https://netbsd.gw.com/cgi-bin/man-cgi?mount_psshfs"><code>mount_psshfs(8)</code></a>.
</p>

<p>
In my case, the backup device is an Apple Time Capsule, being also a
NetBSD-operated device. My first plan, using the remote backup
facility of <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a>, didn't work out because of the missing <a href="https://netbsd.gw.com/cgi-bin/man-cgi?rmt"><code>rmt(8)</code></a>
command on the time capsule. Perhaps some day I'll try to find a
statically linked <a href="https://netbsd.gw.com/cgi-bin/man-cgi?rmt"><code>rmt(8)</code></a> binary for NetBSD-6.0/evbarm (or cross-build
it myself). For now, I'm resolving to using <code>mount_afp</code>, provided
by pkgsrc, and mounting the time capsule filesystem to access it in a
less sophisticated way.
</p>

<p>
BTW, when doing so, I had to manually create a link to <code>/dev/fuse0</code>
(<code>ln -s /dev/putter /dev/fuse0</code>) to make <code>afpfsd</code> work.
Until now, the automatic mounting of the afp device doesn't seem to
work reliably, which kind of counteracts my approach a little bit. I had at
least one case where the <code>afpfsd</code> crashed while dumping. 
</p>

<p>
The second (and more severe) problem with this approach is not being
able to restore from scratch in case of a complete failure. As mentioned, I'd like
to be able to restore from the NetBSD installation mini root
filesystem, which doesn't contain <code>mount_afp</code>. Network tools available there
include <code>rcmd</code> (allowing simple, unsecured remote access via <code>restore</code>,
<code>rexec</code> and <code>rmt</code>), <code>ftp</code> or <code>mount_nfs</code>. For all of them, the
server-side components are missing on the time capsule. So, in case of
a complete restore, my choice will probably be to <code>mount_afp</code> the
backup device onto another system, re-export it from there via nfs and
this way, finally make it reachable for the NetBSD installation mini root.
</p>
</div>
</div>

<div id="outline-container-org686d1ac" class="outline-2">
<h2 id="org686d1ac">Snapshots</h2>
<div class="outline-text-2" id="text-org686d1ac">
<p>
One downside of using <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a> is that it cannot reliably take backups from
live file systems. That used to imply the need to go down to single user and
umount the files systems for each backup. Fortunately, NetBSD has a
nice support for file system snapshots courtesy of <a href="https://netbsd.gw.com/cgi-bin/man-cgi?fssconfig"><code>fssconfig(8)</code></a>,
easing the backup process very much.
</p>

<p>
As root, for example, use
</p>
<div class="org-src-container">
<pre class="src src-shell">fssconfig -cv fss0 / /root/snapshot
</pre>
</div>
<p>
to snapshot the file system and make the snapshot reachable through
the <code>/dev/fss0</code> device. The file <code>/root/snapshot</code> is used internally
to manage the snapshot while the filesystems stays live. You can then
mount the device and see the unchanged directory, even if
you change the live filesystem.
</p>

<p>
<code>fssconfig -l</code> shows the snapshot devices currently in use. With
<code>fssconfig -u</code> you can remove a snapshot after dumping it. Afterwards,
the snapshot file can also be removed.
</p>

<p>
 <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a> logs the time, device and level of each dump into
<code>/etc/dumpdates</code>. Normally, the file system devices are used here. 
But when using fss snapshots, as the fss device name is written into
dumpdates instead, you should always consistently use the same different fss
device numbers when dumping different file systems. For example use <code>fss0</code> for
root, <code>fss1</code> for <code>/usr</code> when they are on different mount points, etc.
</p>

<p>
As I don't want the directory entry for the snapshot to be included
into the dump, I put it into <code>/tmp</code>, which resides on a <code>tmpfs</code> in my
system, so it is guaranteed to not be included into the file system
dumped. When doing
this, an image is generated used as backing store while the snapshot
persists. As this may be too large for the <code>/tmp</code> file system, you can
specify a block size and backing store size in the  <a href="https://netbsd.gw.com/cgi-bin/man-cgi?fssconfig"><code>fssconfig(8)</code></a> call.
This way, I'm giving a smaller size and then mount the <code>fss</code>
device read-only so that the backing store doesn't overflow.
</p>
</div>
</div>

<div id="outline-container-org3df230b" class="outline-2">
<h2 id="org3df230b">Restoring</h2>
<div class="outline-text-2" id="text-org3df230b">
<p>
All this work is done to be able to walk the opposite way and restore a
damaged system in case of an emergency. So lets now have a look on <a href="https://netbsd.gw.com/cgi-bin/man-cgi?restore"><code>restore(8)</code></a>.
It can do full or partial restores and also has an interactive mode.
</p>

<div class="org-src-container">
<pre class="src src-shell">restore -t -f dump_file
</pre>
</div>
<p>
This doesn't modify anything, but just outputs the contents of the
backup. This is not only the file and directory names, but also the
dump date, level and in case of an incremental backup, the previous
level.
</p>

<p>
When doing a full restore into a fresh file system, prepare it using
 <a href="https://netbsd.gw.com/cgi-bin/man-cgi?newfs"><code>newfs(8)</code></a> before. Afterwards,  <a href="https://netbsd.gw.com/cgi-bin/man-cgi?mount"><code>mount(8)</code></a> and <code>cd</code> into the new file system,
as the restored files go into the current directory.
</p>
<div class="org-src-container">
<pre class="src src-shell">restore -rf dump_file
</pre>
</div>
<p>
This rebuilds the file system. When a set of incremental dumps is to be
applied,  <a href="https://netbsd.gw.com/cgi-bin/man-cgi?restore"><code>restore(8)</code></a> needs to pass information between the different runs. So it
creates a <code>restoresymtable</code> file in the root directory storing infos about it's
progress. Consequently, this file should be left
until the complete restore is finished.
</p>

<div class="org-src-container">
<pre class="src src-shell">restore -if dump_file
</pre>
</div>
<p>
This allows you to interactively look into a dump and select single
files or directories to be restored. <code>?</code> shows the commands available here.
Often, when you just want to get back
some older versions of a file, this is the most useful tool. However,
when implementing partial incremental backups as shown above, you only
have backed up versions of the last seven days and of the initial
dump. So if you need more, respect that when defining your strategy.
</p>

<div class="org-src-container">
<pre class="src src-shell">restore -xf dump_file
</pre>
</div>
<p>
This extracts single files or directories instead of doing a full
restore, so it also creates no <code>restoresymtable</code>.
</p>

<p>
And finally,
</p>
<div class="org-src-container">
<pre class="src src-shell">restore -ruf dump_file
</pre>
</div>
<p>
does a full restore, but can be used on a populated file system. It
unlinks and therefore replaces files by the versions from the backup.
So it can be used to try and repair a file system.
By the way, when applying an incremental backup after a full restore,
the files to be replaced by the increment are automatically unlinked before, so
this also works as expected without any need to specify the <code>-u</code> argument.
</p>

<p>
When restoring a backup done with the strategy sketched out above,
start with the (latest) level 0 dump, then work through all newer
dumps leaving out each one where a newer dump with lower level exists.
The dates and other infos about each dump file can be extracted from
output of <code>restore -t</code>, or interactively by using the <code>what</code> command
in <code>restore -i</code>. For example, when dumps were generated with order <code>0
3 2 4</code>, you'll find that for level 3 dump a newer one with lower level
exists (number 2), so 3 is left out. The only one with lower level
than 2 is the older 0, so you choose 2. 4 has also only lower ones
with older dates, so 4 is also choosen, giving the restore order <code>0 2
4</code>.
</p>
</div>
</div>

<div id="outline-container-org33e5d8f" class="outline-2">
<h2 id="org33e5d8f">Some more notes</h2>
<div class="outline-text-2" id="text-org33e5d8f">
<p>
You can exclude files or directories from the backup by setting the
<code>nodump</code> flag. <code>ls -o</code> shows the current flags. Set <code>nonodump</code> to
remove a flag.
</p>
<div class="org-src-container">
<pre class="src src-shell">chflags nodump file-or-dir
ls -o
chflags nonodump file-or-dir
</pre>
</div>

<p>
By default, the <code>nodump</code> flags are honored for incremental backups
starting with level 1, but you can change this with the <code>dump -h</code>
option. I'm setting this to 0 to always have the flags honored.
</p>
<div class="org-src-container">
<pre class="src src-shell">dump 0a -h 0 -f /tmp/backup.1 /home
</pre>
</div>
<p>
For example, I'm using this to exclude <code>/usr/pkgsrc</code> from the backup.
</p>

<p>
Otherwise, you can also specify a list of paths, when only a subset of
a file system should be backed up. When doing this,  <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a> is always
doing a full level 0 backup of the given directories.
</p>

<p>
When a long dump is running, you can send a <code>SIGSTATUS</code> to the dump
process to make it report it's progress. For example, when the status
control character is mapped to <code>CTRL-T</code> via <a href="https://netbsd.gw.com/cgi-bin/man-cgi?stty"><code>stty(1)</code></a>, a dump process running in the
foreground reports the progress when pressing that (restore also).
</p>

<p>
If you are manually doing backups, besides looking at <code>/etc/dumpdates</code>
you can use <code>dump -w</code> to show the file systems currently to be dumped.
Otherwise, you can always use <code>dump -W</code> to show the last dump times and
levels of all dumped file systems. <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a> is also integrated into the
housekeeping concepts of NetBSD insofar, as this output is included into the
<a href="https://netbsd.gw.com/cgi-bin/man-cgi?daily"><code>daily(5)</code></a> maintainance tool.
</p>

<p>
The dump frequency in days, used to determine which file systems need
to be dumped next, can be defined in <code>/etc/fstab</code>'s fifth entry.
But when using snapshots, the devices actually dumped are not listed
in fstab, so this mechanism isn't working. Automating the backup in a
crontab and defining dump entries with adjacent frequencies can
mitigate this.
</p>
</div>
</div>

<div id="outline-container-orgcaa57f3" class="outline-2">
<h2 id="orgcaa57f3">An example session</h2>
<div class="outline-text-2" id="text-orgcaa57f3">
<p>
Here is an example of mounting/unmounting an afp backup device,
handling a file system snapshot and doing a full dump.
</p>

<div class="org-src-container">
<pre class="src src-shell">mount_afp afp://:passwd@host/path /mnt/backup
fssconfig -cv fss0 / /snapshot
mount /dev/fss0 /mnt/dev
dump -0ua -h 0 -f /mnt/backup/dumpfile.0 /mnt/dev
umount /mnt/dev
fssconfig -u fss0
rm /snapshot 
afp_client unmount /mnt/backup
</pre>
</div>

<p>
To do a restore, you would use the same sequence, replacing the <code>dump</code>
command perhaps with an interactive restore:
</p>
<div class="org-src-container">
<pre class="src src-shell">restore -if /mnt/backup/var
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ee32b4" class="outline-2">
<h2 id="org7ee32b4">Putting the pieces together</h2>
<div class="outline-text-2" id="text-org7ee32b4">
<p>
Most of this is put together into a bash script, <code>backup.sh</code> (see
below at the end).
When sourced, it provides some commands
to support handling snapshots, mounting of the backup device,
making an incremental backup following a configured strategy and
accessing/restoring from the backup device. For example, after
modifying the conf file to your needs, a manual
initial level 0 dump can be done like this:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">.</span> /root/bin/backup.sh &amp;&amp; backup - 0
</pre>
</div>
<p>
An interactive restore session of the last level 5 dump is done by
this:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #483d8b;">.</span> /root/bin/backup.sh &amp;&amp; restoredump - -i 5
</pre>
</div>
<p>
The script includes an example on how
to automate daily backups by calling it via crontab, saving the output
to a log and mailing it to root.
</p>
</div>
</div>

<div id="outline-container-org73397bb" class="outline-2">
<h2 id="org73397bb">At the end&#x2026;</h2>
<div class="outline-text-2" id="text-org73397bb">
<p>
After a few days of automatic backups, this setup seems to work quite
reliably. The files are rotated and replaced in the expected order,
looking at the contents with interactive restore and doing a test recovery, everything looks
good. Having set up this kind of backups gives some confidence&#x2014;now
lets make sure continuously this actually is justified..
</p>

<p>
Other, more sophisticated means of data security include usage of
zfs or raids, which one day may be topic of further explorations..
</p>

<p>
As a side note, while experimenting with  <a href="https://netbsd.gw.com/cgi-bin/man-cgi?dump"><code>dump(8)</code></a> and <a href="https://netbsd.gw.com/cgi-bin/man-cgi?restore"><code>restore(8)</code></a>,
I stumbled upon
the last dump made on my NeXTStep System some decades ago. And,
believe it or not, the <a href="https://netbsd.gw.com/cgi-bin/man-cgi?restore"><code>restore(8)</code></a> command on 2020's NetBSD is still
able to read that old dump format. So when I'll find some more time, I
hope to restore it into a virtualized NeXTStep reincarnation. That
would be a recovery strategy having been worked out really well!
</p>
</div>
</div>

<div id="outline-container-orga63a93a" class="outline-2">
<h2 id="orga63a93a">Appendix: the backup script</h2>
<div class="outline-text-2" id="text-orga63a93a">
<p>
Take caution as this is not yet well enough tested&#x2014;just use it as a
simple example. For example, make sure that two dumps of different
file systems don't run at the same time. Otherwise, the first one finishing will
unmount the backup device, making the second one fail.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;">#</span><span style="color: #b22222;">!/usr/pkg/bin/</span><span style="color: #a020f0;">bash</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">copy and adapt the config vars into ~/etc/backup.conf</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">put auth info like DUMPDEVPWD into ~/.backup.conf</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">and set it chmod 400 and chflags nodump</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">install as root crontab like this:</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;"># daily backups</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">0       1       *       *       *       /usr/pkg/bin/bash -c '. /root/bin/backup.sh &amp;&amp; backup /root/etc/backup-var.conf' 2&gt;&amp;1 | tee /var/log/backup-var.out | sendmail -t</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">30      1       *       *       *       /usr/pkg/bin/bash -c '. /root/bin/backup.sh &amp;&amp; backup' 2&gt;&amp;1 | tee /var/log/backup.out | sendmail -t</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">uncomment to test backup config</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">TEST=echo</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">define this when dump device must be mounted</span>
<span style="color: #a0522d;">DUMPDEV</span>=afp://:${<span style="color: #a0522d;">DUMPDEVPWD</span>}@timecapsule/ 
<span style="color: #a0522d;">DUMPMNT</span>=/mnt/bkup

<span style="color: #b22222;"># </span><span style="color: #b22222;">unset if you dont want a snapshot</span>
<span style="color: #a0522d;">FSS</span>=fss0
<span style="color: #a0522d;">SRCDEV</span>=/
<span style="color: #a0522d;">SNAPSHOT</span>=/tmp/snapshot

<span style="color: #b22222;"># </span><span style="color: #b22222;">mountpoint of fs to backup</span>
<span style="color: #a0522d;">SRCMNT</span>=/mnt/dev

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup device or file</span>
<span style="color: #a0522d;">BACKUP</span>=${<span style="color: #a0522d;">DUMPMNT</span>}/client/dump
<span style="color: #b22222;">#</span><span style="color: #b22222;">BACKUP=</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup levels for each day of month</span>
<span style="color: #a0522d;">LEVELS</span>=(- 0 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2)

<span style="color: #0000ff;">dumpcmd</span>() {
  ${<span style="color: #a0522d;">TEST</span>} dump $<span style="color: #a0522d;">*</span>
}

<span style="color: #0000ff;">restorecmd</span>() {
  ${<span style="color: #a0522d;">TEST</span>} restore $<span style="color: #a0522d;">*</span>
}

<span style="color: #483d8b;">export</span> <span style="color: #a0522d;">PATH</span>=$<span style="color: #a0522d;">PATH</span>:/usr/pkg/bin

<span style="color: #b22222;"># </span><span style="color: #b22222;">absolute paths to use in root crontab</span>
<span style="color: #483d8b;">test</span> -f /root/.backup.conf &amp;&amp; <span style="color: #483d8b;">.</span> /root/.backup.conf
<span style="color: #483d8b;">test</span> -f /root/etc/backup.conf &amp;&amp; <span style="color: #483d8b;">.</span> /root/etc/backup.conf

<span style="color: #0000ff;">backup_dev</span>() {
  <span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${DUMPMNT}-"</span> != <span style="color: #8b2252;">"-"</span> ]; <span style="color: #a020f0;">then</span>
    <span style="color: #a020f0;">case</span> <span style="color: #8b2252;">"$1"</span><span style="color: #a020f0;"> in</span>
    mount) ${<span style="color: #a0522d;">TEST</span>} mount_afp ${<span style="color: #a0522d;">DUMPDEV</span>} ${<span style="color: #a0522d;">DUMPMNT</span>}
           ;;
    unmount) ${<span style="color: #a0522d;">TEST</span>} afp_client unmount ${<span style="color: #a0522d;">DUMPMNT</span>}
             ;;
    <span style="color: #a020f0;">esac</span>
  <span style="color: #a020f0;">fi</span>
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">when the time capsule needs to spin up, mount seems to fail</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">so a second try is done</span>
<span style="color: #0000ff;">mount_backup</span>() {
  backup_dev mount
  <span style="color: #a020f0;">if</span> [ $<span style="color: #a0522d;">?</span> -eq 2 ]; <span style="color: #a020f0;">then</span>
    backup_dev mount
  <span style="color: #a020f0;">fi</span>
}

<span style="color: #0000ff;">snapshot</span>() {
  <span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${FSS}-"</span> != <span style="color: #8b2252;">"-"</span> ]; <span style="color: #a020f0;">then</span>
    <span style="color: #a020f0;">case</span> $<span style="color: #a0522d;">1</span><span style="color: #a020f0;"> in</span>
    new) ${<span style="color: #a0522d;">TEST</span>} fssconfig -c ${<span style="color: #a0522d;">FSS</span>} ${<span style="color: #a0522d;">SRCDEV</span>} ${<span style="color: #a0522d;">SNAPSHOT</span>} 512 10485760
         ${<span style="color: #a0522d;">TEST</span>} mount -r /dev/${<span style="color: #a0522d;">FSS</span>} ${<span style="color: #a0522d;">SRCMNT</span>}
         ;;
    rm) ${<span style="color: #a0522d;">TEST</span>} umount ${<span style="color: #a0522d;">SRCMNT</span>}
        ${<span style="color: #a0522d;">TEST</span>} fssconfig -u ${<span style="color: #a0522d;">FSS</span>}
        ${<span style="color: #a0522d;">TEST</span>} rm -f ${<span style="color: #a0522d;">SNAPSHOT</span>}
        ;;
    <span style="color: #a020f0;">esac</span>
  <span style="color: #a020f0;">fi</span>
}

<span style="color: #0000ff;">find_level</span>() {
  <span style="color: #b22222;"># </span><span style="color: #b22222;">find level for today</span>
  <span style="color: #a0522d;">LEV</span>=${<span style="color: #a0522d;">LEVELS</span>[<span style="color: #ff00ff;">`date '+%e'`</span>]}
  <span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${1}-"</span> != <span style="color: #8b2252;">"-"</span> ]; <span style="color: #a020f0;">then</span>
    <span style="color: #a0522d;">LEV</span>=${<span style="color: #a0522d;">1</span>}
  <span style="color: #a020f0;">fi</span>
  <span style="color: #a020f0;">if</span> [ <span style="color: #8b2252;">"${BACKUP}-"</span> != <span style="color: #8b2252;">"-"</span> ]; <span style="color: #a020f0;">then</span>
    <span style="color: #a0522d;">BACKUPFILE</span>=${<span style="color: #a0522d;">BACKUP</span>}<span style="color: #483d8b;">.</span>${<span style="color: #a0522d;">LEV</span>}
    <span style="color: #a0522d;">BOUT</span>=
  <span style="color: #a020f0;">else</span>
    <span style="color: #a0522d;">BACKUPFILE</span>=
    <span style="color: #a0522d;">BOUT</span>=-
  <span style="color: #a020f0;">fi</span>
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">makedump lev</span>
<span style="color: #0000ff;">makedump</span>() {
  find_level ${<span style="color: #a0522d;">1</span>}

  <span style="color: #b22222;"># </span><span style="color: #b22222;">save prev lev 0 dump as prevmonth</span>
  <span style="color: #a020f0;">if</span> [ ${<span style="color: #a0522d;">LEV</span>} -eq 0 ]; <span style="color: #a020f0;">then</span>
    <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevmonth &amp;&amp; rm ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevmonth
    <span style="color: #483d8b;">test</span> <span style="color: #8b2252;">"${BACKUPFILE}-"</span> != <span style="color: #8b2252;">"-"</span> &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>} &amp;&amp; mv ${<span style="color: #a0522d;">BACKUPFILE</span>} ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevmonth
  <span style="color: #a020f0;">fi</span>

  <span style="color: #b22222;"># </span><span style="color: #b22222;">save prev lev 1 dump as prevweek</span>
  <span style="color: #a020f0;">if</span> [ ${<span style="color: #a0522d;">LEV</span>} -eq 1 ]; <span style="color: #a020f0;">then</span>
    <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevweek &amp;&amp; rm ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevweek
    <span style="color: #483d8b;">test</span> <span style="color: #8b2252;">"${BACKUPFILE}-"</span> != <span style="color: #8b2252;">"-"</span> &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>} &amp;&amp; mv ${<span style="color: #a0522d;">BACKUPFILE</span>} ${<span style="color: #a0522d;">BACKUPFILE</span>}.prevweek
  <span style="color: #a020f0;">fi</span>

  <span style="color: #b22222;"># </span><span style="color: #b22222;">all other levs: rm instead of overwriting</span>
  <span style="color: #a020f0;">if</span> [ ${<span style="color: #a0522d;">LEV</span>} -gt 1 ]; <span style="color: #a020f0;">then</span>
    <span style="color: #483d8b;">test</span> <span style="color: #8b2252;">"${BACKUPFILE}-"</span> != <span style="color: #8b2252;">"-"</span> &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">BACKUPFILE</span>} &amp;&amp; rm ${<span style="color: #a0522d;">BACKUPFILE</span>}
  <span style="color: #a020f0;">fi</span>

  <span style="color: #b22222;"># </span><span style="color: #b22222;">and dump</span>
  dumpcmd ${<span style="color: #a0522d;">LEV</span>}ua -h 0 -f ${<span style="color: #a0522d;">BACKUPFILE</span>}${<span style="color: #a0522d;">BOUT</span>} ${<span style="color: #a0522d;">SRCMNT</span>} 
}

<span style="color: #0000ff;">mailheader</span>() {
  <span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"To: root"</span>
  <span style="color: #483d8b;">printf</span> <span style="color: #8b2252;">"Subject: %s backup dump output for %s\n\n"</span> <span style="color: #ff00ff;">`hostname`</span> <span style="color: #8b2252;">"`date`"</span>
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup [conf [lev]]</span>
<span style="color: #0000ff;">backup</span>() {
  mailheader
  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for custom conf</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 0 &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">1</span>} &amp;&amp; <span style="color: #483d8b;">.</span> ${<span style="color: #a0522d;">1</span>}
  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for lev</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 1 &amp;&amp; <span style="color: #a0522d;">LEV</span>=${<span style="color: #a0522d;">2</span>} || <span style="color: #a0522d;">LEV</span>=
  find_level $<span style="color: #a0522d;">LEV</span>

  snapshot new
  <span style="color: #b22222;"># </span><span style="color: #b22222;">backup_dev mount</span>
  mount_backup
  makedump $<span style="color: #a0522d;">LEV</span>
  backup_dev unmount
  snapshot rm
}

<span style="color: #b22222;"># </span><span style="color: #b22222;">restoredump [conf [args [lev]]]</span>
<span style="color: #0000ff;">restoredump</span>() {
  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for custom conf</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 0 &amp;&amp; <span style="color: #483d8b;">test</span> -f ${<span style="color: #a0522d;">1</span>} &amp;&amp; <span style="color: #483d8b;">.</span> ${<span style="color: #a0522d;">1</span>}

  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for args</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 1 &amp;&amp; <span style="color: #a0522d;">ARGS</span>=${<span style="color: #a0522d;">2</span>}

  <span style="color: #b22222;"># </span><span style="color: #b22222;">check for lev</span>
  <span style="color: #483d8b;">test</span> $<span style="color: #a0522d;">#</span> -gt 2 &amp;&amp; <span style="color: #a0522d;">LEV</span>=${<span style="color: #a0522d;">3</span>} || <span style="color: #a0522d;">LEV</span>=
  find_level $<span style="color: #a0522d;">LEV</span>

  <span style="color: #b22222;"># </span><span style="color: #b22222;">backup_dev mount</span>
  mount_backup
  restorecmd ${<span style="color: #a0522d;">ARGS</span>} -f ${<span style="color: #a0522d;">BACKUPFILE</span>}${<span style="color: #a0522d;">BOUT</span>}
  backup_dev unmount
}
</pre>
</div>

<p>
..and an example of a backup.conf showing how to dump/restore using
ssh pipes:
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #b22222;"># </span><span style="color: #b22222;">comment to really do backups</span>
<span style="color: #a0522d;">TEST</span>=echo

<span style="color: #b22222;"># </span><span style="color: #b22222;">define this when dump device must be mounted</span>
<span style="color: #a0522d;">DUMPDEV</span>=afp://:${<span style="color: #a0522d;">DUMPDEVPWD</span>}@timecapsule/
<span style="color: #a0522d;">DUMPMNT</span>=/mnt/bkup

<span style="color: #b22222;"># </span><span style="color: #b22222;">unset if you dont want a snapshot</span>
<span style="color: #a0522d;">FSS</span>=fss0
<span style="color: #a0522d;">SRCDEV</span>=/
<span style="color: #a0522d;">SNAPSHOT</span>=/tmp/snapshot

<span style="color: #b22222;"># </span><span style="color: #b22222;">mountpoint of fs to backup</span>
<span style="color: #a0522d;">SRCMNT</span>=/mnt/dev

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup device or file</span>
<span style="color: #a0522d;">BACKUP</span>=${<span style="color: #a0522d;">DUMPMNT</span>}/client/dump
<span style="color: #b22222;">#</span><span style="color: #b22222;">BACKUP=</span>

<span style="color: #b22222;"># </span><span style="color: #b22222;">backup levels for each day of month</span>
<span style="color: #a0522d;">LEVELS</span>=(- 0 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2 5 4 7 6 1 3 2)

<span style="color: #b22222;"># </span><span style="color: #b22222;">uncomment this to define custom commands</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">dumpcmd() {</span>
<span style="color: #b22222;">#  </span><span style="color: #b22222;">dump $* | ssh timecapsule dd of=/Volumes/dk2/ShareRoot/client/dump.${LEV}</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">}</span>

<span style="color: #b22222;">#</span><span style="color: #b22222;">restorecmd() {</span>
<span style="color: #b22222;">#  </span><span style="color: #b22222;">ssh timecapsule dd if=/Volumes/dk2/ShareRoot/client/dump.${LEV} | restore $*</span>
<span style="color: #b22222;">#</span><span style="color: #b22222;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jörg Kollmann
(Reddit: <a href="https://www.reddit.com/user/e17i">u/e17i</a>)</p> <p>Made on
emacs org-mode with <a href="https://jessekelly881-rethink.surge.sh/">Rethink</a></p>
</div>
</body>
</html>
